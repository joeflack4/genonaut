"""Utilities for managing PostgreSQL sequences and IDENTITY columns."""

from __future__ import annotations

import logging
from typing import Optional, Sequence

from sqlalchemy import text
from sqlalchemy.engine import Engine
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.sql import sqltypes

from genonaut.db.schema import Base

LOGGER = logging.getLogger(__name__)


def reset_all_sequences(engine: Engine, tables: Optional[Sequence[str]] = None) -> int:
    """Reset all IDENTITY/sequence columns to match actual table data.

    When importing data with explicit IDs, PostgreSQL sequences don't automatically
    advance. This function resets each table's sequence to MAX(id) + 1 to prevent
    duplicate key violations on subsequent inserts.

    Handles both:
    - Modern IDENTITY columns (GENERATED BY DEFAULT AS IDENTITY)
    - Traditional SERIAL columns with sequences

    Only resets sequences for tables with integer primary keys (skips UUID PKs).

    Args:
        engine: SQLAlchemy engine for database connection
        tables: Optional list of table names to reset. If None, resets all tables.

    Returns:
        Number of tables/sequences successfully reset

    Example:
        >>> from sqlalchemy import create_engine
        >>> from genonaut.db.utils.sequences import reset_all_sequences
        >>> engine = create_engine("postgresql://...")
        >>> count = reset_all_sequences(engine)
        >>> print(f"Reset {count} sequences")
    """
    if tables is None:
        tables = list(Base.metadata.tables.keys())

    reset_count = 0

    with engine.connect() as conn:
        for table_name in tables:
            # Each table reset is its own transaction to avoid cascading failures
            try:
                # Skip tables that don't have id columns
                table = Base.metadata.tables.get(table_name)
                if table is None or not hasattr(table.c, 'id'):
                    continue

                # Skip tables with non-integer primary keys (e.g., UUID)
                id_column = table.c.id
                if not isinstance(id_column.type, sqltypes.Integer):
                    LOGGER.debug("Skipping %s (non-integer primary key)", table_name)
                    continue

                # Start a transaction for this table
                trans = conn.begin()

                try:
                    # Get max ID from table
                    max_id_result = conn.execute(text(f"SELECT COALESCE(MAX(id), 0) FROM {table_name}"))
                    max_id = max_id_result.scalar()
                    next_id = max_id + 1

                    # Try IDENTITY column first (modern PostgreSQL)
                    try:
                        conn.execute(text(f"ALTER TABLE {table_name} ALTER COLUMN id RESTART WITH {next_id}"))
                        LOGGER.info("Reset IDENTITY for %s (next ID: %d)", table_name, next_id)
                        reset_count += 1
                        trans.commit()
                    except SQLAlchemyError:
                        # Rollback and try traditional sequence
                        trans.rollback()
                        trans = conn.begin()

                        try:
                            seq_name_result = conn.execute(text(
                                f"SELECT pg_get_serial_sequence('{table_name}', 'id')"
                            ))
                            seq_name = seq_name_result.scalar()

                            if seq_name:
                                # The 'false' parameter means the value is not immediately used
                                conn.execute(text(f"SELECT setval('{seq_name}', {next_id}, false)"))
                                LOGGER.info("Reset sequence for %s (next ID: %d)", table_name, next_id)
                                reset_count += 1
                                trans.commit()
                            else:
                                LOGGER.debug("Skipping %s (no sequence or IDENTITY column)", table_name)
                                trans.commit()
                        except SQLAlchemyError as e:
                            trans.rollback()
                            LOGGER.debug("Could not reset sequence for %s: %s", table_name, str(e))
                except Exception:
                    trans.rollback()
                    raise

            except SQLAlchemyError as e:
                LOGGER.debug("Skipping %s due to error: %s", table_name, str(e))

    return reset_count


def reset_table_sequence(engine: Engine, table_name: str) -> bool:
    """Reset a single table's sequence/IDENTITY column.

    Args:
        engine: SQLAlchemy engine for database connection
        table_name: Name of the table to reset

    Returns:
        True if sequence was reset, False otherwise
    """
    reset_count = reset_all_sequences(engine, tables=[table_name])
    return reset_count > 0
