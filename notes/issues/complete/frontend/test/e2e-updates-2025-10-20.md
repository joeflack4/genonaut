# E2E Test Updates - Analytics Tests

This document outlines the tasks to fix the 6 skipped analytics E2E tests that fail due to React Query timing issues.

## Context

We've skipped 6 analytics E2E tests due to persistent React Query timing issues:
- Route Analytics - changes time range filter
- Route Analytics - persists filter selections across page reload
- Generation Analytics - displays generation metrics
- Generation Analytics - displays generation chart or empty state
- Generation Analytics - displays recent generations table or empty state
- Generation Analytics - changes time range filter

All analytics functionality is verified working via manual testing and MCP Playwright browser verification. These are
purely test environment timing issues.

**Approach**: Instead of fixing the skipped tests, we'll CREATE NEW tests using a loading indicator pattern. The old s
kipped tests will remain as educational examples of what NOT to do, while the new tests demonstrate the correct pattern
for testing components with complex React Query dependencies.

## Implementation Plan

### Phase 1: Add Loading State Indicators (Architectural Fix)

**IMPORTANT:** These loading indicators should ONLY be added to the analytics components that are tested by the skipped
tests. Do NOT apply this pattern to all frontend E2E tests - only to fix these specific analytics test timing issues.

**Affected Components:**
- `frontend/src/components/analytics/RouteAnalyticsCard.tsx`
- `frontend/src/components/analytics/GenerationAnalyticsCard.tsx`
- `frontend/src/components/analytics/TagCardinalityCard.tsx` (if needed)

**Tasks:**

- [x] **Add loading indicators to RouteAnalyticsCard**
  - Add `data-testid="route-analytics-loading"` to loading skeleton/state
  - Add `data-testid="route-analytics-loaded"` to the container when data is successfully loaded
  - Use React Query's `isLoading` and `isSuccess` states to conditionally render these
  - Ensure the "loaded" indicator appears when ALL queries have resolved (not just one)

- [x] **Add loading indicators to GenerationAnalyticsCard**
  - Add `data-testid="generation-analytics-loading"` to loading skeleton/state
  - Add `data-testid="generation-analytics-loaded"` to the container when data is successfully loaded
  - Use React Query's `isLoading` and `isSuccess` states to conditionally render these
  - Ensure stats grid, chart, and table sections all wait for data before showing "loaded" state

- [x] **Update E2E test helper to wait for loaded state**
  - Update `frontend/tests/e2e/utils/realApiHelpers.ts` or create new helper
  - Add function like `waitForAnalyticsDataLoaded(page, section)` that waits for:
    - `[data-testid="route-analytics-loaded"]` for route analytics
    - `[data-testid="generation-analytics-loaded"]` for generation analytics
  - Use timeout of 30s to allow for slow queries
  - Call this helper in test `beforeEach` or before interactions

- [x] **Create NEW analytics tests using loading indicators**
  - In `frontend/tests/e2e/analytics-real-api.spec.ts`
  - KEEP the existing 6 skipped tests as-is (they serve as documentation of the problematic pattern)
  - Create NEW test cases modeled on the skipped tests, with names like:
    - `changes time range filter (with loading indicators)`
    - `persists filter selections across page reload (with loading indicators)`
    - `displays generation metrics (with loading indicators)`
    - `displays generation chart or empty state (with loading indicators)`
    - `displays recent generations table or empty state (with loading indicators)`
    - `changes time range filter (with loading indicators)` (for generation analytics)
  - In the `beforeEach` for these new tests, call the wait helper AFTER `waitForPageLoad`
  - Example: `await waitForAnalyticsDataLoaded(page, 'route')` and `await waitForAnalyticsDataLoaded(page, 'generation')`
  - Add documentation comments to the new tests explaining they use the loading indicator pattern
  - This ensures ALL data is loaded before tests interact with filters

- [x] **Run NEW analytics E2E tests to verify they pass**
  - Run: `npm --prefix frontend run test:e2e -- tests/e2e/analytics-real-api.spec.ts`
  - Expected: 22 passing (6 old tests still skipped, 6 new tests passing)
  - Total should be: 16 (originally passing) + 6 (new with loading indicators) = 22 passing, 6 skipped
  - **Result**: All 6 new tests passing! Total: 22 passing, 6 skipped (as expected)
  - One test needed increased timeout (persistence test with page reload) - fixed with `test.setTimeout(30000)`

- [x] **Update test documentation to explain the two approaches**
  - Add a comment block at the top of the analytics test file explaining:
    - The 6 skipped tests demonstrate the problematic pattern (React Query timing without explicit indicators)
    - The 6 new tests demonstrate the recommended pattern (using loading indicators)
    - Keep both sets of tests for educational purposes

- [x] **Document loading indicator pattern in docs/testing.md**
  - Location: Add to the "E2E Test Patterns to Avoid" section (around line 1277, after "Recommended Alternatives")
  - Add a new subsection called "✅ Handling React Query Timing Issues"
  - Document the loading indicator pattern as a recommended approach
  - Include code examples showing:
    - How to add `data-testid` loading indicators to components
    - How to create a helper function to wait for data loaded state
    - Example test code using the pattern
  - Reference the analytics tests as a successful implementation
  - Emphasize this is for components with complex async data dependencies (React Query, etc.)
  - Note: This pattern should be used selectively, not globally applied to all E2E tests

  **Example content to add to docs/testing.md:**
  ```markdown
  ### ✅ Handling React Query Timing Issues

  For components with complex React Query dependencies that cause E2E test timing failures, use explicit loading indicators with data-testid attributes:

  **Pattern:**
  ```typescript
  // Component: Add loading state indicators
  function AnalyticsCard() {
    const { data, isLoading, isSuccess } = useQuery(...)

    if (isLoading) {
      return <div data-testid="analytics-loading">Loading...</div>
    }

    if (isSuccess) {
      return (
        <div data-testid="analytics-loaded">
          {/* Your content */}
        </div>
      )
    }
  }

  // Test Helper: Wait for data to load
  async function waitForAnalyticsDataLoaded(page, section: 'route' | 'generation') {
    await page.waitForSelector(`[data-testid="${section}-analytics-loaded"]`, {
      timeout: 30000
    })
  }

  // Test: Use the helper before interactions
  test('changes filter', async ({ page }) => {
    await page.goto('/analytics')
    await waitForAnalyticsDataLoaded(page, 'route')

    // Now safe to interact with filters
    await page.click('[data-testid="filter-select"]')
  })
  ```

  **When to use this pattern:**
  - Components with multiple cascading React Query hooks
  - Analytics/dashboard pages with slow aggregation queries
  - Pages where `networkidle` doesn't guarantee data is ready
  - Tests failing with "element not found" despite long timeouts

  **When NOT to use:**
  - Simple pages with single query
  - Tests that already pass reliably
  - Global application - only add to problematic components

  **Example:** Analytics E2E tests (`frontend/tests/e2e/analytics-real-api.spec.ts`) use this pattern successfully after fixing persistent timing issues.
  ```

### Phase 2: Add Component Tests with Mock Data

**IMPORTANT:** These component tests with mock data should ONLY be created for the analytics components to replace the problematic E2E test coverage. Do NOT apply this pattern to other component tests in the codebase - only create these specific analytics component tests to provide alternative test coverage for the functionality covered by the skipped E2E tests.

These component tests will provide faster, more reliable test coverage for analytics functionality without the timing issues of full E2E tests.

**Tasks:**

- [ ] **Create test fixtures for analytics mock data**
  - Create `frontend/src/components/analytics/__tests__/fixtures.ts`
  - Add mock data for:
    - `mockRouteAnalyticsData` - route performance metrics
    - `mockGenerationAnalyticsData` - generation metrics, stats, chart data
    - `mockTagCardinalityData` - tag distribution data
  - Ensure data matches the actual API response structure

- [ ] **Create component tests for RouteAnalyticsCard**
  - Create `frontend/src/components/analytics/__tests__/RouteAnalyticsCard.test.tsx`
  - Tests to add:
    - Renders route analytics table with mock data
    - Shows empty state when no data
    - Time range filter changes trigger re-query (test state change, not actual query)
    - Top N filter changes trigger re-query
    - Filter selections persist in localStorage (can mock localStorage)
  - Use `@testing-library/react` with `userEvent` for interactions
  - Wrap component in `QueryClientProvider` with mock data

- [ ] **Create component tests for GenerationAnalyticsCard**
  - Create `frontend/src/components/analytics/__tests__/GenerationAnalyticsCard.test.tsx`
  - Tests to add:
    - Renders generation metrics stats grid with mock data
    - Shows empty state when no data
    - Chart renders with mock data
    - Table renders with mock data
    - Time range filter changes trigger re-query
  - Use similar testing pattern as RouteAnalyticsCard

- [ ] **Create component tests for TagCardinalityCard**
  - Create `frontend/src/components/analytics/__tests__/TagCardinalityCard.test.tsx`
  - Tests to add:
    - Tabs switch between Table and Visualization views
    - Log scale toggle works in Visualization tab
    - Top N selectors work for both Regular and Auto-Generated content
    - Data displays correctly in both tabs
  - These should already be well-tested by E2E, so focus on edge cases

- [ ] **Add test scripts and run component tests**
  - Ensure `npm run test-unit` runs the new component tests
  - Run tests: `npm --prefix frontend run test-unit`
  - Verify all component tests pass
  - Add to CI pipeline if not already included

## Success Criteria

- [x] 6 NEW analytics E2E tests created and passing (using loading indicator pattern)
- [x] Original 6 skipped tests remain skipped (serve as educational examples of problematic pattern)
- [x] Total test count: 22 passing + 6 skipped = 28 tests
- [x] New tests run reliably without timing failures (run multiple times, all passed)
- [ ] Component tests provide fast, reliable coverage for analytics interactions (Phase 2 - optional)
- [x] Loading indicators only added to analytics components (not applied globally)
- [x] Documentation updated in both test file and docs/testing.md to explain both approaches

## Alternative Solutions (If Phase 1 Doesn't Work)

If adding loading indicators doesn't fully resolve the timing issues, consider:

1. **Use MSW (Mock Service Worker)** - Mock API responses in E2E tests for predictable timing
2. **Use `page.waitForResponse()`** - Wait for specific API calls before interactions
3. **Increase Playwright default timeout** - Set `timeout: 60000` globally for analytics tests
4. **Accept E2E tests as flaky** - Keep them skipped, rely on component tests for coverage

## Notes

- The analytics page is fully functional and production-ready
- These changes are test improvements, not bug fixes
- Manual testing confirms all functionality works correctly
- **Educational approach**: Keep both old (skipped) and new (passing) tests to demonstrate:
  - Old tests: What NOT to do (timing-dependent tests without explicit loading indicators)
  - New tests: What TO do (using loading indicators for React Query components)
- Focus on Phase 1 first - if it works, Phase 2 is optional but recommended for faster test suite
- This pattern should ONLY be applied to the analytics components for these specific tests - not a global pattern
